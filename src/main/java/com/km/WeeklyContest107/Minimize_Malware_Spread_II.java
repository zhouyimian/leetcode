package com.km.WeeklyContest107;

import java.util.*;

public class Minimize_Malware_Spread_II {
	int[] parent;

	public int minMalwareSpread(int[][] graph, int[] initial) {
		Set<Integer> set=new HashSet<>();
		Arrays.sort(initial);
		int N=graph.length;
		parent=new int[N];
		Arrays.fill(parent, -1);
		for(int num:initial)
			set.add(num);
		for(int i=0;i<N;i++) {
			if(set.contains(i))
				continue;
			for(int j=0;j<N;j++) {
				if(i==j||set.contains(j))
					continue;
				if(graph[i][j]==1) {
					union(i,j);
				}
			}
		}
		int ans=Integer.MAX_VALUE;
		int ans_point=-1;
		for(int i=0;i<initial.length;i++) {
			Map<Integer,Integer> counts=new HashMap<>();
			for(int j=0;j<initial.length;j++) {
				if(i==j)
					continue;
				for(int k=0;k<N;k++) {
					if(k==initial[i]) continue;
					if(graph[k][initial[j]]==1) {
						int root=find(k);
						counts.putIfAbsent(root,-parent[root]);
					}
				}
			}
			int temp=0;
			for(int value:counts.values())
				temp+=value;
			if(temp<ans) {
				ans=temp;
				ans_point=initial[i];
			}
		}
		return ans_point;
	}

	private int find(int x) {
		if(parent[x]<0)
			return x;
		parent[x]=find(parent[x]);
		return parent[x];
	}

	private void union(int x, int y) {
		x=find(x);
		y=find(y);
		if(x==y)
			return;
		if(parent[x]>parent[y]) {
			parent[y]+=parent[x];
			parent[x]=y;
		}
		else {
			parent[x]+=parent[y];
			parent[y]=x;
		}
	}
}
